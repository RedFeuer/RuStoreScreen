# План фич

## Фичи

1. Список приложений *(12 дней = 1 спринт)*
2. Карточка приложения *(12 дней = 1 спринт)*
3. Установка и удаление приложений

---

## 1. Список приложений \(\~12 дней\)

### Эпики

1.1. UI списка приложений \(\~3 дня\)  
1.2. Модель данных и Source of Truth \(\~4\.5–5 дней\)  
1.3. Логика состояния списка приложений \(\~3\.5–4 дня\)

---

### 1.1. UI списка приложений \(\~3 дня\)

1.1.1. Вёрстка экрана списка приложений для разных состояний `AppListScreen` \(\~1 день, 8 часов\)  
1.1.2. Отображение snacks \(\~4 часа\)  
1.1.3. UI\-тесты \(\~1 день, 8 часов\)

---

### 1.2. Модель данных и Source of Truth \(\~4\.5–5 дней\)

1.2.1. UseCase\-ы для получения данных \(\~2 часа\)  
1.2.2. Repository для работы с источниками данных \(сеть, БД\) \(\~1 день, 8 часов\)  
1.2.3. Конфигурация для API \- репозиторий для работы с запросами к API \(\~4 часа\)  
1.2.4. Конфигурация БД \- конвертеры, DAO, определение базы данных \(\~4 часа\)  
1.2.5. Внедрение зависимостей \(\~1 день\)  
1.2.6. Тестовые \(mock\) данные \(\~4 часа\)  
1.2.7. Unit\-тесты \(\~1 день\)

---

### 1.3. Логика состояния списка приложений \(\~3\.5–4 дня\)

1.3.1. Создание `ViewModel` \(\~2 часа\)  
1.3.2. Создание `State`: `Error`, `Loading`, `Content` \(\~4 часа\)  
1.3.3. Интеграция `UseCase`, `Repository` и `State` в методы обновления состояния экранов \(\~1 день\)  
1.3.4. Внедрение events \(snacks\) \(\~4 часа\)  
1.3.5. Интеграционные тесты \(многопоточность, `Flow` при обновлении состояния\) \(\~1 день\)

---

## 2. Карточка приложения \(\~12 дней\)

**Заметка:** структура аналогична фиче *Список приложений*, но добавляются `Entity`, `Dto` и `Mapper`\-ы.

### Эпики

2.1. UI карточки приложения \(\~3 дня\)  
2.2. Модель данных и Source of Truth \(\~4\.5–5 дней\)  
2.3. Логика состояния карточки приложения \(\~3\.5–4 дня\)

---

### 2.1. UI карточки приложения \(\~3 дня\)

2.1.1. Вёрстка экрана конкретного приложения для разных состояний `AppDetailsScreen` \(\~1 день, 8 часов\)  
2.1.2. Отображение snacks \(\~4 часа\)  
2.1.3. UI\-тесты \(\~1 день, 8 часов\)

---

### 2.2. Модель данных и Source of Truth \(\~4\.5–5 дней\)

2.2.1. UseCase\-ы для получения данных \(\~2 часа\)  
2.2.2. Repository для работы с источниками данных \(сеть, БД\) \(\~1 день, 8 часов\)  
2.2.3. DTO для данных из сети \(\~1 час\)  
2.2.4. Конфигурация API \- репозиторий для работы с запросами к API \(\~4 часа\)  
2.2.5. Entity для данных из БД \(\~1 час\)  
2.2.6. Конфигурация БД \- конвертеры, DAO, определение базы данных \(\~4 часа\)  
2.2.7. Создание mapper\-ов `DTO <-> Domain` и `Entity <-> Domain` \(\~2 часа\)  
2.2.8. Внедрение зависимостей \(\~1 день\)  
2.2.9. Тестовые \(mock\) данные \(\~4 часа\)  
2.2.10. Unit\-тесты \(\~1 день\)

---

### 2.3. Логика состояния карточки приложения \(\~3\.5–4 дня\)

2.3.1. Создание `ViewModel` \(\~2 часа\)  
2.3.2. Создание `State`: `Error`, `Loading`, `Content` \(\~4 часа\)  
2.3.3. Интеграция `UseCase`, `Repository` и `State` в методы обновления состояния экрана \(\~1 день\)  
2.3.4. Внедрение events \(snacks\) \(\~4 часа\)  
2.3.5. Интеграционные тесты \(многопоточность, `Flow`\) \(\~1 день\)

---

## 3. Установка и удаление приложений \(\~7 дней\)

### Эпики

3.1. UI состояния установки  \(\~2\.5–3 дня\)
3.2. Логика установки \(\~3\.5–4 дня\)

---

### 3.1. UI состояния установки \(\~2\.5–3 дня\)

3.1.1. Вёрстка кнопки установки \(\~2 часа\)  
3.1.2. Индикация прогресса на кнопке \(изменение состояния\) \(\~1 день\)  
3.1.3. UI\-тестирование \(\~1 день\)

---

### 3.2. Логика установки \(\~3\.5–4 дня\)

3.2.1. Добавление состояний загрузки приложения \(\~2 часа\)  
3.2.2. Реализация `UseCase` установки приложения и внедрение в `ViewModel` \(\~4 часа\)  
3.2.3. `MockRepository` для тестирования на специальных тестовых `.apk` \(\~4 часа\)  
3.2.4. Тестовые данные \(\~4 часа\)  
3.2.5. Repository установки приложения \(\~1 день\)  
3.2.6. Сохранение и выгрузка информации о статусе загрузки в БД \(\~4 часа\)
